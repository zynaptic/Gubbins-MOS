/*
 * The Gubbins Microcontroller Operating System
 *
 * Copyright 2023 Zynaptic Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

/*
 * This file implements the management functions to be used for general
 * purpose sensor feeds. Sensor feeds provide a high level abstraction
 * for streams of sensor data points generated by arbitrary sensor data
 * sources.
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#include "gmos-config.h"
#include "gmos-platform.h"
#include "gmos-scheduler.h"
#include "gmos-streams.h"
#include "gmos-sensor-feeds.h"

// Define a stream type for carrying sensor feed data.
GMOS_STREAM_DEFINITION (gmosSensorStream, gmosSensorFeedData_t)

/*
 * Implement the sensor processing state machine task. This accepts
 * sensor data from the sensor feed input and forwards it to each of the
 * sensor feed outputs.
 */
static inline gmosTaskStatus_t gmosSensorFeedTaskFn (
    gmosSensorFeed_t* sensorFeed)
{
    gmosTaskStatus_t taskStatus = GMOS_TASK_RUN_IMMEDIATE;
    gmosStream_t* inputStream = &(sensorFeed->inputStream);
    gmosSensorFeedData_t* feedData = &(sensorFeed->feedData);

    // Attempt to read the next data item for subsequent processing.
    if (sensorFeed->feedOutput == NULL) {
        if (gmosSensorStream_read (inputStream, feedData)) {
            sensorFeed->feedOutput = sensorFeed->feedOutputList;
        } else {
            taskStatus = GMOS_TASK_SUSPEND;
        }
    }

    // Attempt to write out the current data item to all the sensor feed
    // output streams.
    while (sensorFeed->feedOutput != NULL) {
        gmosSensorFeedOutput_t* currentOutput = sensorFeed->feedOutput;
        gmosStream_t* outputStream = &(currentOutput->outputStream);

        // Filter the sensor feed data before sending it to the output.
        // Idle the task if the output is not ready to accept the data.
        if ((currentOutput->dataFilter == NULL) ||
            (currentOutput->dataFilter (feedData))) {
            if (!gmosSensorStream_write (outputStream, feedData)) {
                break;
            }
        }

        // Process the next output if available.
        sensorFeed->feedOutput = currentOutput->nextOutput;
    }
    return taskStatus;
}

// Define the feed task for forwarding sensor data.
GMOS_TASK_DEFINITION (
    gmosSensorFeedTask, gmosSensorFeedTaskFn, gmosSensorFeed_t)

/*
 * Initialises a new sensor feed data structure on startup. This should
 * be called once for each sensor feed instance prior to subsequent use.
 */
void gmosSensorFeedInit (gmosSensorFeed_t* sensorFeed,
    uint16_t maxDataItems)
{
    // Initialise the sensor feed data structure.
    gmosSensorStream_init (&(sensorFeed->inputStream),
        &(sensorFeed->feedTask), maxDataItems);
    sensorFeed->feedOutputList = NULL;
    sensorFeed->feedOutput = NULL;

    // Start the sensor feed processing task.
    gmosSensorFeedTask_start (&(sensorFeed->feedTask),
        sensorFeed, "Sensor Feed Processing");
}

/*
 * Adds a new output to a given sensor feed. This should be called after
 * the sensor feed has been initialised in order to add sensor feed
 * outputs for sensor data processing.
 */
void gmosSensorFeedAddOutput (gmosSensorFeed_t* sensorFeed,
    gmosSensorFeedOutput_t* sensorFeedOutput,
    gmosSensorFeedFilter_t dataFilter,
    gmosTaskState_t* consumerTask)
{
    // Initialise the sensor feed output data structure.
    gmosSensorStream_init (&(sensorFeedOutput->outputStream),
        consumerTask, 1);
    sensorFeedOutput->dataFilter = dataFilter;

    // Attach the output data structure to the sensor feed.
    sensorFeedOutput->nextOutput = sensorFeed->feedOutputList;
    sensorFeed->feedOutputList = sensorFeedOutput;
}

/*
 * Writes a new scalar value sensor feed data item to a sensor feed,
 * adding it to the sensor feed input queue.
 */
bool gmosSensorFeedWriteScalar (gmosSensorFeed_t* sensorFeed,
    uint8_t sensorId, int32_t value, uint8_t sensorUnits,
    int8_t sensorScaling)
{
    gmosStream_t* inputStream = &(sensorFeed->inputStream);
    gmosSensorFeedData_t feedData;

    // Populate the sensor feed data structure.
    feedData.sensorId = sensorId;
    feedData.sensorUnits = sensorUnits;
    feedData.sensorScaling = sensorScaling;
    feedData.vectorSize = 0;
    feedData.timestamp = gmosPalGetTimer ();
    feedData.value.scalar = value;

    // Attempt to queue the sensor data.
    return gmosSensorStream_write (inputStream, &feedData);
}

/*
 * Writes a new vector value sensor feed data item to a sensor feed,
 * adding it to the sensor feed input queue.
 */
bool gmosSensorFeedWriteVector (gmosSensorFeed_t* sensorFeed,
    uint8_t sensorId, int32_t* vector, uint8_t vectorSize,
    uint8_t sensorUnits, int8_t sensorScaling)
{
    gmosStream_t* inputStream = &(sensorFeed->inputStream);
    gmosSensorFeedData_t feedData;
    uint_fast8_t i;

    // Check for maximum vector size limit.
    if ((vectorSize == 0) ||
        (vectorSize > GMOS_CONFIG_SENSOR_FEED_MAX_VECTOR_SIZE)) {
        GMOS_ASSERT_FAIL ("Invalid sensor data vector size.");
        return false;
    }

    // Copy over the data vector.
    for (i = 0; i < vectorSize; i++) {
        feedData.value.vector [i] = vector [i];
    }

    // Populate the sensor feed data structure.
    feedData.sensorId = sensorId;
    feedData.sensorUnits = sensorUnits;
    feedData.sensorScaling = sensorScaling;
    feedData.vectorSize = vectorSize;
    feedData.timestamp = gmosPalGetTimer ();

    // Attempt to queue the sensor data.
    return gmosSensorStream_write (inputStream, &feedData);
}

/*
 * Reads the next sensor feed data from a sensor feed output, removing
 * it from the associated sensor feed output queue.
 */
bool gmosSensorFeedRead (gmosSensorFeedOutput_t* sensorFeedOutput,
    gmosSensorFeedData_t* feedData)
{
    gmosStream_t* outputStream = &(sensorFeedOutput->outputStream);
    return gmosSensorStream_read (outputStream, feedData);
}
